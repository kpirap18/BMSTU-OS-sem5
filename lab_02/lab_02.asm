; 286 страница (Р-Ф)

; В защищенном режиме программа не может выйти за пределы
; Объявленых ею сегментов, а также не может выполнить
; Действия, запрещенные атрибутами сегмента.

; Подключаем данную директиву, чтобы работать с 
; Расширенным набором команд. (Р-Ф).

.386P

; Структура для описания дескрипторов сегментов.
; В з-р для каждого сегмента программы долже быть
; Определен дескриптор - 8-байтовое поле, в котором
; в определенном формате записываются базовый адрес сегмента, 
; его длина и некоторые другие характеристики. 
; В р-р сегменты определяются их базовыми адресами. (Р-Ф).

; Начало объялвения структуры. (Описание структуры != выделение памяти).
descr struc		; 
limit dw 0		; Номер последнего байта сегмента (Тут 16 бит).
base_l dw 0		; База сегмента - определяет начальный линейный адрес сегмента в адр. пространтве.
				; Лин. адр. - выражен не в виде (сегмент:смещение), а просто номером байта
				; В адресном пространстве (В нашем случае лин. адр. тоже самое что и физич. 
				; (но это в общем случае не так) если включена страничная адр. то лин. адр.
				; может не совпадать с физическим, если выключена, то совпадают).
				; Сегмент в з-р может располагаться в любом месте адр. пространства 4Гбайт.
				; (base_1) 16 + (base_m) 8 + (base_h) 8 = 32  
base_m db 0		; 
attr_1 db 0		; Байт атрибутов 1
attr_2 db 0		; Тут находятся старшие 4 бита номера последнего байта сегмента 
				; (в сумме получается (lim==) 16 + 4 (0..3 бит attr_2) = 20 
				; Получается, что размер сегмента ограничен 1Мбайт = 2^20 байт)
				; Старший бит attr_2 указывает в каких единицах задается граница (бит дробности)
				; Если == 0, то граница указывается в байтах
				; Если == 1, то в блоках по 4Кбайт (Т.е. тогда сегмент будет 
				; ограничен 4Гбайт (2^20 *2^10 (==Кбайт) = 2^30 байт == 1Гбайт))
base_h db 0		; База, биты 24-31
descr ends		


; Сегмент данных
data segment use16		; use16 - это тип. в данном сегменте будут использоваться 16-битовые адреса.
						; мы работаем под ДОС, которая работает в реальном режиме с 16бит адресами и операндами
						; Выделяем память под соответсвующие структуры (под дескрипторы).
						; Т.е. выше мы просто описали стректуру, а тут выделяем 
						; Память, задавая явно параметры.
						; Мы описываем эти дескрипторы потому что в з-р мы можем обращаться к сегментами
						; Только используя их (дескрипторы). 
						; Таблица глобальных дескрипторов GDT.						
gdt_null descr <0,0,0,0,0,0>					
gdt_data descr <data_size-1,0,0,92h, 0, 0>	 ; 92h 1001 0010 -	
    ; этот код (92h) говорит о том, что это сегмент данных с разрешением записи и чтения) 
gdt_code descr <code_size-1,0,0,98h,0,0>	 ; 98h 1001 1000 -
; 98h - задаем attr_1 (сегмент команд)
    ; этот код (98h) говорит о том, что исполняемый сегмент, 
	; к которому запрещено обращение с целью записи и чтения.
gdt_stack descr <255,0,0,92h, 0,0>				
gdt_screen descr <4095,8000h,0Bh,92h,0,0>		
	; gdt_screen - это дескриптор видеопамяти (Чтобы выводить символы). 
	; 255 байт - соответствует размеру стека. 
gdt_size=$-gdt_null								

; Различные данные программы
pdescr 	dq 0		
sym 	db 1		
attr 	db 1Eh		
s      	db ?		

mes db 27, '[31; 42m Back real mode ', 27, '[0m$'
msg_real_mode db 'real mode', 13, 10, '$'
msg_real_back db 'back real mode', 13, 10, '$'
msg_prot_mode db ' IN protected mode '
data_size=$-gdt_null
data ends


; Сегмент команд.
text segment 'code' use16
	assume CS:text, DS:data
main proc
	xor eax, eax ; Обнуляем регистр EAX.
	mov AX, data ; Инициализируем регистр DS для работы в р-р.
	mov DS, AX 
	
    ; Линейные (32-битовые) адреса определяются путем умножения значений
    ; сегментных адресов на 16.
	shl eax, 4 ; В EAX теперь лежит линейный 32-битовый адрес.
	mov ebp, eax ; Т.к. этот адрес будет дальше использоваться он созраняется в EBP.
	mov bx, offset gdt_data ; В BX загружается смещение дескрипттора сегмента данных.
	mov [bx].base_l, ax ; В дескриптор заноситтся младшая половина лин. адреса (данных вроде).
	rol eax, 16 ; сдвигаем  вправо (т.к. к старшей половине мы не можем обратиться в 16-разр.-р.)
	mov [bx].base_m, al ; В base_m заносим заносим содержимое AL.

	xor eax, eax ; Обнуляем регистр EAX.
	
	; Аналогично вычисляются и заносятся в соответствующие поля дескрипторов 
    ; (gdt_code и gdt_stack) 32-битовые линейные адреса сегментов команд и стека.
	mov ax, cs
	shl eax, 4
	mov bx, offset gdt_code
	mov [bx].base_l, ax
	rol eax, 16
	mov [bx].base_m, al

	xor eax, eax
	mov ax, ss
	shl eax, 4
	mov bx, offset gdt_stack
	mov [bx].base_l, ax
	rol eax, 16
	mov [bx].base_m, al
	
	
	; LGDT (Load GDT) - загружает в регистр процессора GDTR (GDT Register)
    ; информацию о таблице глобольных дескрипторов 
    ; (лин. базовый адрес (4 байта) таблицы и ее границу (2 байта)). (Размещается в 6-байтах.)
    ; Т.е. там лежит линейный адрес начала таблицы глобальных дескрипторов.
	mov dword ptr pdescr+2, ebp ; Заносится лин. адрес GDT.
	mov word ptr pdescr, gdt_size-1 ; Заносится поле границы.
	lgdt pdescr ; pdescr - псевдодескриптор.

	mov ah, 09h
	mov dx, offset msg_real_mode
	int 21h

	; Переходим в з-р.  
    ; Устанавливаем бит PE 
    ; в управляющем регистре процессора CR0
    ; Обращение к регистром управления CR0
    ; Осуществляется исключительно командой MOV (причем второй операнд должен быть рег. общ. назначения).
    ; Поэтому мы сначала записывае CR0 в рег. общ. назначания EAX
    ; Поднимаем флаг PM, а потом перезаписываем содержимое регистра управления CR0.
	cli
	mov al, 80h
	out 70h, al

	mov eax, cr0
	or eax, 1 ; Поднимаем бит, которые переведет процессор в з-р.
	mov cr0, eax ; Вот тут переводим в з-р процессор.
	
	 ; Теперь процессор работает в з-р.
    ; Для кажого из сегментных регистров имеется теневой регистр дескриптора,
    ; который имеет формат дескриптора. Тен. рег. не доступны программисту.
    ; Они автоматически загружаются процессором из таблицы дескрипторов
    ; Каждый раз, когда процессор инициализирует соответствующий сегментный регистр.
    ; В з-р прогаммист имеет дело с селекторами, т.е. номерами дескрипторов,
    ; А процессор с самими дескрипторами, хранящимися в теневых регистрах.
    ; (Лин адрес сегмента, который хранится в тен. рег. определяет область памяти,
    ; К которой обращается процессор при выполнении конкретной программы).
	
	
	; Загружаем в CS:IP селектор:смещение точки continue. 
    ; Мы используем jmp (дальнего перехода), чтобы изменить содержимое CS:IP
    ; Т.к. нам недоступно прямое образение к регистру CS 
    ; (мы не можем загрузить туда селектор).
	db 0EAh
	dw offset continue
	; Смещение.
    ; Указатель на описание сегмента называется селектор. 
    ; Другими словами, селектор - это номер дескриптора из таблицы дескрипторов.
	dw 16  ; Селектор сегмента команд. (Записываем селектор, т.к. в з-р)

continue:
	; Загружаем селекторы в сегментные регистры DS, SS, и ES 
    int 3
    ; Делаем адресуемыми данные. 
    ; Загружаем в DS селектор сегмента данных.
	mov ax, 8
	mov ds, ax
	
    ; Делаем адресуемым стек. 
    ; Загружаем в SS селектор сегмента стека.
	mov ax, 24
	mov ss, ax

    ; Загружаем в SS селектор сегмента видеобуфера.
 	mov ax, 32
 	mov es, ax
	
    mov cx, 18
 	mov si, offset msg_prot_mode
 	mov di, 700
 	mov ah, attr

screen_prot_mode:
	lodsb
 	stosw
    loop screen_prot_mode

	; Возвращаемся в реальный режим. 
	; При работе в р-р поля теневых регистров должны быть
	; заполнены определенным способом. Так для сегментов
	; Данных, стека и коода должны быть установлены границы FFFFh 
	; (любое другое значение не устраивает р-р)
	; (Бит дробности должен быть установлен в 0. Доступ для записи 
	; разрешен - это для стека и данных). 

	; Если мы просто перейдем в р-р сбросом бита в регистре CR0
	; То в тен. рег. останутся дескрипторы з-р и при первом же обращении
	; К любому сегменту программы возникнет иключение общей защиты, 
	; Т.к. ни один из наших сегментов не имеет границы, равной FFFFh. 
	; (Произойдет сброс процессора и перезагрузка комп.)
	
	mov gdt_data.limit, 0FFFFh
	mov gdt_code.limit, 0FFFFh
	mov gdt_stack.limit,0FFFFh
	mov gdt_screen.limit,0FFFFh


	; Далее идет перезапись теневых регистров 
	; МОжно сделать 2м способами (закомменчены) и нет
	; Загрузка селекторов в сегментные регистры -> перезапись теневых регистров
	;mov ax, 8
	;mov ds, ax
	;mov ax, 24
	;mov ss, ax
	;mov ax, 32
	;mov es, ax

	push ds
	pop ds
	
	push ss
	pop ss
	
	push es
	pop es
	
	; (Регистр CS непосредственно загрузить нельзя,
	; Поэтому выполняем искусственно сформированный вызов дальнего перехода).
	; Выполняет дальний переход, чтобы заново загрузить селектор
	; В регистр CS и модифицировать его тен. рег.
	db 0EAh ; Команда дальнего перехода
	dw offset go
	dw 16


go:
; Сбрасываем бит защищенного режима.
	mov eax, CR0
	and eax, 0FFFFFFFEh
	mov CR0, eax
	
	; ПЕРЕШЛИ В р-р.
	; Снова выполняем дальний переход, 
	; Чтобы загрузить в регистр CS вместо хранящегося там селектора
	; Обычный сегментный адрес регистра команд.
	db 0EAh
	dw offset return
	dw text
	
; (Вот сюда мы вернемся когда выйдем из з-р, т.е. вернемся в р-р)
return:

; Т.к. передача управления на метку return осуществляется
    ; Программами BIOS, то эти программы использовали регистры процессора.
    ; Поэтому нам нужна заново инициализировать их (В частности SS, DS и SP)
    ; Восстанавливаем вычислительную среду реального времени. 

	; После перехода в р-р необходимо загрузить
	; В используемые далее сегментные регистры 
	; соответствубщие сегментные адреса.
	mov AX, data
	mov DS, AX
	mov AX, stk
	mov SS, AX

	sti  ; Резрешаем (аппаратные) прерывания

	; Теперь программа может продолжить работать в р-р.
    ; Для проверки работоспособности выводится текст
	mov ah, 09h
	mov dx, offset msg_real_back
	int 21h

	mov ax, 4C00h
	int 21h


main endp
code_size=$-main
text ends
stk segment stack 'stack'
	db 256 dup('^')
stk ends
	end main