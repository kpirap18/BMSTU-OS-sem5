\chapter{Исследовательская часть}

В данном разделе будут приведены примеры работы программ, постановка эксперимента и сравнительный анализ алгоритмов на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item Операционная система: Ubuntu 20.04.3 \cite{ubuntu} Linux \cite{linux} x86\_64.
	\item Память: 8 GiB.
	\item Процессор: 11th Gen Intel® Core™ i5-1135G7 @ 2.40GHz \cite{intel}.
\end{itemize}

Тестирование проводилось на ноутбуке, включенном в сеть электропитания. Во время тестирования ноутбук был нагружен только встроенными приложениями окружения, а также непосредственно системой тестирования.

\section{Демонстрация работы программы}

На рисунке \ref{img:example} представлен результат работы программы.

\img{140mm}{example}{Пример работы программы}

\section{Время выполнения алгоритмов}

Алгоритмы тестировались при помощи функции process\_time() из библиотеки time языка Python. Данная функция всегда возвращает значения времени, а имеено сумму системного и пользовательского процессорного времени текущего процессора, типа float в секундах.

Контрольная точка возвращаемого значения не определна, поэтому допустима только разница между результатами последовательных вызовов.

Замеры времени для каждой длины слов проводились 100 раз. В качестве результата взято среднее время работы алгоритма на данной длине слова.

Результаты замеров приведены в таблице \ref{tab:time} (время в мкс).

\begin{table}[h]
	\begin{center}
		\caption{\label{tab:time}Результаты замеров времени.}
		\begin{tabular}{|c|c|c|c|c|}
			
			\hline
			Длина & Л.(матр.)& Л.(рек с матр.) & Л.(рек)  & Д.-Л.(рек.)  \\
			\hline
			0 & 1.43534 & 1.80707 & 0.43232 & 0.41829 \\
			\hline
			1 & 2.26853 & 2.91881 & 1.25935 & 1.23623 \\
			\hline
			2 & 4.20428 & 6.41375 & 5.12573 & 5.43740 \\
			\hline
			3 & 9.01130 & 14.53429 & 31.56933 & 33.42077 \\
			\hline
			4 & 10.05873 & 16.91644 & 114.69468 & 127.88060 \\
			\hline
			5 & 15.02883 & 25.31050 & 633.12262 & 692.21623 \\
			\hline
			6 & 15.91587 & 27.53538 & 2650.31546 & 2918.78975 \\
			\hline
			7 & 23.33747 & 37.99432 & 15230.66448 & 16730.88525 \\
			\hline
			8 & 42.62168 & 74.88248 & 123855.96710 & 135893.39700 \\
			\hline
			9 & 51.07370 & 87.96769 & 639529.53498 & 700352.48553 \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

На рисунке \ref{img:figure6} представлен график сравнения рекурсивных реализаций алгоритмов поиска расстояния Левенштейна с использованием кеша и без. На графике видно, что полученные результаты частично накладываются друг на друга (до длины равной 6).

На рисунке \ref{img:figure5} представлен график сравнения рекурсивных реализаций алгоритмов поиска расстояния Левенштейна и Дамерау-Левенштейна. На графике видно, что полученные результаты частично накладываются друг на друга (до длины равной 7).

На рисунке \ref{img:figure4} представлен график сравнения матричной реализаций алгоритма поиска расстония Левенштейна и рекурсивного алгоритма поиска расстояния Левенштейна с использованием кеша.

\img{120mm}{figure2}{Сравнения рекурсивных алгоритмов поиска расстояния Левенштейна с использованием кеша и без}
\img{120mm}{figure1}{Сравнения рекурсивных алгоритмов поиска расстояния Левенштейна и Дамерау-Левенштейна}
\img{120mm}{figure4}{Сравнения матричного алгоритма поиска расстояния Левенштейна и рекурсивного алгоритма поиска расстояния Левенштейна с использованием кеша}
 
\section{Использование памяти}

Алгоритмы нахождения расстояний Левенштейна и Дамерау -- Левенштейна не отличаются друг от друга с точки зрения использования памяти, поэтому достаточно рассмотреть лишь разницу рекурсивной и матричной реализаций данных алгоритмов.

Пусть длина строки S1 - n, длина строки S2 - m, тогда затраты памяти на приведенные выше алгоритмы будут следующими:
\begin{itemize}
	\item матричный алгоритм поиска расстояния Левенштейна:\begin{itemize}
		\item строки S1, S2 - (m + n) * sizeof(char)
		\item матрица - ((m + 1) * (n + 1)) * sizeof(int)
		\item текущая строка матрицы - (n + 1) * sizeof(int)
		\item длины строк - 2 * sizeof(int)
		\item вспомогательные переменные -  3 * sizeof(int)
	\end{itemize}
\end{itemize}

Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящий строк.

\begin{itemize}
	\item рекурсивный алгоритм поиска расстояния Левенштейна (для каждого вызова):\begin{itemize}
		\item строки S1, S2 - (m + n) * sizeof(char)
		\item длины строк - 2 * sizeof(int)
		\item вспомогательные переменные -  2 * sizeof(int)
		\item адрес возврата
	\end{itemize}
	\item рекурсивный алгоритм поиска расстояния Левенштейна с использованием кеша (для каждого вызова): Для всех вызовов еще память для хранения самой матрицы -  ((m + 1) * (n + 1)) * sizeof(int) \begin{itemize}
		\item строки S1, S2 - (m + n) * sizeof(char)
		\item длины строк - 2 * sizeof(int)
		\item вспомогательные переменные -  2 * sizeof(int)
		\item ссылка на матрицу - 8 байт
		\item адрес возврата
	\end{itemize}
	\item рекурсивный алгоритм поиска расстояния Дамерау-Левенштейна(для каждого вызова):\begin{itemize}
		\item строки S1, S2 - (m + n) * sizeof(char)
		\item длины строк - 2 * sizeof(int)
		\item вспомогательная переменная -  sizeof(int)
		\item адрес возврата
	\end{itemize}
\end{itemize}


\section*{Вывод}

Рекурсивный алгоритм нахождения расстояния Левенштейна работает на порядок дольше итеративных реализаций, время его работы увеличивается в геометрической прогрессии. На словах длиной 10 символов, матричная реализация алгоритма нахождения расстояния Левенштейна превосходит по времени работы рекурсивную на несколько порядков.

Рекурсивный алгоритм с заполнением матрицы превосходит простой рекурсивный и сравним по времени работы с матричными алгоритмами. 

Алгоритм нахождения расстояния Дамерау — Левенштейна по времени выполнения сопоставим с алгоритмом нахождения расстояния Левенштейна. В нём добавлена дополнительная проверка, позволяющая находить ошибки пользователя, связанные с неверным порядком букв, в связи с чем он работает незначительно дольше, чем алгоритм нахождения расстояния Левенштейна.

Но по расходу памяти итеративные алгоритмы проигрывают рекурсивному: максимальный размер используемой памяти в них растёт как произведение длин строк, в то время как у рекурсивного алгоритма — как сумма длин строк.
